/* Task 1

var a = 1, b = 1, c, d;

c = ++a; alert(c);           // 2
-> Здесь используется префиксный инкремент. Он возвращает значение операнда, увеличенного на единицу (сначала увеличивает, потом возвращает), поэтому c присваивается значение a + 1 = 2.

d = b++; alert(d);           // 1
-> Здесь используется постфиксный инкремент. Он сначала возвращает значение операнда, а потом увеличивает его на 1, поэтому d присваивается исходное значение b = 1. Значение b после этой строчки уже равно 2.

c = (2+ ++a); alert(c);      // 5
-> Исходно a тут равно 2 (после операции ++a). Первой тут выполняется операция префиксного инкремента, соответственно, a становится равно 3. Затем выполняется вторая операция в скобках - сложение с 2. 2 + a = 2 + 3 = 5. И уже после этого значение в скобках присваивается переменной c. Соответственно, с = 5 (а все еще равно 3).

d = (2+ b++); alert(d);      // 4
-> Исходно b тут тоже равно 2. Пример похож на предыдущих, однако так как постфиксный оператор сначала возвращает значение операнда, а потом его увеличивает, в скобках 2 складывается с 2 и получается 4. Поэтому d = 4 (а b равно 3).

alert(a);                    // 3
alert(b);                    // 3
-> В принципе, выше уже описано, почему значения переменных a и b равны 3, но можно и повторить: обе переменные исходно были заданы равными 1, а затем дважды были увеличены на 1. 1 + 1 + 1 = 3.

*/

/* Task 2

var a = 2;
var x = 1 + (a *= 2);
-> Первой выполняется операция в скобках. а *= 2 - это краткая запись операции умножения с присваиванием а = а * 2. Значит, после этой операции a = 4. Затем идет сложение с 1 и присваивание результата переменной x, значит, x = 1 + 4 = 5.
Проверим?

*/

var a = 2;
var x = 1 + (a *= 2);
alert('Задание 2\n\nЧему будет равен x в примере ниже?\nvar a = 2;\nvar x = 1 + (a *= 2);\n\nОтвет: x = ' + x);

// Task 3
alert('Задание 3');
a = +prompt('Введите первое целое число:');         // parseInt не может распознать дробное число, поэтому я использовала +
var b = +prompt('Введите второе целое число:');     // Хотя теперь пустая строка и пробелы преобразуются в 0...

if (isNaN(a) || isNaN(b)) {
    alert('Вы не числа ввели...');
} else if ((a - Math.round(a) != 0) || (b - Math.round(b) != 0)) {
    alert('Вы не целые числа ввели...');
} else if (a >= 0 && b >= 0) {
    alert('Поздравляю, Вы ввели целые числа!\na = ' + a + ', b = ' + b + '\nОба числа положительные.\nРазность введенных чисел равна ' + Math.abs(a - b));
} else if (a < 0 && b < 0) {
    alert('Поздравляю, Вы ввели целые числа!\na = ' + a + ', b = ' + b + '\nОба числа отрицательные.\nПроизведение введенных чисел равно ' + a * b);
} else {
    alert('Поздравляю, Вы ввели целые числа!\na = ' + a + ', b = ' + b + '\nВведенные числа разных знаков.\nСумма введенных чисел равна ' + (a + b));
}

// Task 4
alert('Задание 4');
a = parseInt(prompt('Введите любое число от 0 до 15 включительно:'));
var numbers = '';
if (isNaN(a) || a < 0 || a > 15) {
    alert('Вы уверены, что ввели то, что требовалось?');
} else {
    for (var i = a; i < 15; i++) {
        numbers += i + ', ';
    }
    alert(numbers + 15);
}

// Task 4 (with switch and in the range [0...5])
alert('Задание 4 (с использованием switch)');
a = parseInt(prompt('Введите любое число от 0 до 5 включительно:'));
numbers = '';
switch (a) {
    case 0:
        numbers += a++ + ', ';
    case 1:
        numbers += a++ + ', ';
    case 2:
        numbers += a++ + ', ';
    case 3:
        numbers += a++ + ', ';
    case 4:
        numbers += a++ + ', ';
    case 5:
        numbers += a;
        alert(numbers);
        break;
    default:
        alert('Вы уверены, что ввели то, что требовалось?');
        break;
}

// Task 5
function sum(arg1, arg2) {
    return arg1 + arg2;
}

function dif(arg1, arg2) {
    return arg1 - arg2;
}

function prod(arg1, arg2) {
    return arg1 * arg2;
}

function div(arg1, arg2) {
    return arg1 / arg2;
}

// Task 6

function mathOperation(arg1, arg2, operation) {
    switch (operation) {
        case '+':
            return sum(arg1, arg2);
            break;
        case '-':
            return dif(arg1, arg2);
            break;
        case '*':
            return prod(arg1, arg2);
            break;
        case '/':
            return div(arg1, arg2);
            break;
        default:
            return 'Вы уверены, что ввели то, что требовалось?';
            break;
    }
}

alert('Задание 6');
a = +prompt('Введите первое число');
b = +prompt('Введите второе число');
op = prompt('Введите одну из четырех операций: +, -, *, /');
alert(mathOperation(a, b, op));

// Task 7

alert('Задание 7');
alert('null === 0: ' + (null === 0) +
    '\nРезультат строгого равенства предсказуем: при таком сравнении не происходит приведения типов, а так как null - не число, то с числом 0 он не совпадает' +
    '\n\nnull == 0: ' + (null == 0) +
    '\nПри нестрогом равенстве, по идее, должно происходить приведение типов. Однако в результате все равно выходит "ложь". Видимо, null не приводится к числовому типу даже в этом случае, так как является особым типом (отвечает за пустое значение). Судя по тому, что написано в справочниках, то же верно и для undefined. При этом, если вручную преобразовать null к числу, получится 0:\n+null === 0: ' + (+null === 0) + '\n+null == 0: ' + (+null == 0) +
    '\n\nnull <= 0: ' + (null <= 0) +
    '\nnull >= 0: ' + (null >= 0) +
    '\nnull < 0: ' + (null < 0) +
    '\nnull > 0: ' + (null > 0) +
    '\nА вот при нестрогих сравнениях приведение типа явно происходит, иначе первые две строки не выдали бы "правду".');

// Task 8

function power(val, pow) {
    if (pow == 0) {
        return (val == 0) ? undefined : 1;
    } else if (val == 0) {
        return (pow > 0) ? 0 : 'infinity';
    } else if (pow > 0) {
        return val * power(val, --pow);
    } else {
        return 1 / val * power(val, ++pow);
    }
}

alert('Задание 8');
a = +prompt('Введите число:');
var n = +prompt('Введите значение степени (любое целое число):');
if (isNaN(a) || isNaN(n) || (n - Math.round(n) != 0)) {
    alert('Вы уверены, что ввели то, что требовалось?');
} else {
    var res = power(a, n);
    (n >= 0)
        ? alert('a = ' + a + '\nn = ' + n + '\na\u207F = ' + res)
        : alert('a = ' + a + '\nn = ' + n + '\na\u207F = 1/' + power(a, -n) + ' = ' + res);
}
